// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'tag_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TagFailureTearOff {
  const _$TagFailureTearOff();

  _NotSupportedTag notSupportedTag() {
    return const _NotSupportedTag();
  }

  _TagError tagError() {
    return const _TagError();
  }
}

/// @nodoc
const $TagFailure = _$TagFailureTearOff();

/// @nodoc
mixin _$TagFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notSupportedTag,
    required TResult Function() tagError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notSupportedTag,
    TResult Function()? tagError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotSupportedTag value) notSupportedTag,
    required TResult Function(_TagError value) tagError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotSupportedTag value)? notSupportedTag,
    TResult Function(_TagError value)? tagError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagFailureCopyWith<$Res> {
  factory $TagFailureCopyWith(
          TagFailure value, $Res Function(TagFailure) then) =
      _$TagFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$TagFailureCopyWithImpl<$Res> implements $TagFailureCopyWith<$Res> {
  _$TagFailureCopyWithImpl(this._value, this._then);

  final TagFailure _value;
  // ignore: unused_field
  final $Res Function(TagFailure) _then;
}

/// @nodoc
abstract class _$NotSupportedTagCopyWith<$Res> {
  factory _$NotSupportedTagCopyWith(
          _NotSupportedTag value, $Res Function(_NotSupportedTag) then) =
      __$NotSupportedTagCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotSupportedTagCopyWithImpl<$Res>
    extends _$TagFailureCopyWithImpl<$Res>
    implements _$NotSupportedTagCopyWith<$Res> {
  __$NotSupportedTagCopyWithImpl(
      _NotSupportedTag _value, $Res Function(_NotSupportedTag) _then)
      : super(_value, (v) => _then(v as _NotSupportedTag));

  @override
  _NotSupportedTag get _value => super._value as _NotSupportedTag;
}

/// @nodoc

class _$_NotSupportedTag extends _NotSupportedTag {
  const _$_NotSupportedTag() : super._();

  @override
  String toString() {
    return 'TagFailure.notSupportedTag()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotSupportedTag);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notSupportedTag,
    required TResult Function() tagError,
  }) {
    return notSupportedTag();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notSupportedTag,
    TResult Function()? tagError,
    required TResult orElse(),
  }) {
    if (notSupportedTag != null) {
      return notSupportedTag();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotSupportedTag value) notSupportedTag,
    required TResult Function(_TagError value) tagError,
  }) {
    return notSupportedTag(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotSupportedTag value)? notSupportedTag,
    TResult Function(_TagError value)? tagError,
    required TResult orElse(),
  }) {
    if (notSupportedTag != null) {
      return notSupportedTag(this);
    }
    return orElse();
  }
}

abstract class _NotSupportedTag extends TagFailure {
  const factory _NotSupportedTag() = _$_NotSupportedTag;
  const _NotSupportedTag._() : super._();
}

/// @nodoc
abstract class _$TagErrorCopyWith<$Res> {
  factory _$TagErrorCopyWith(_TagError value, $Res Function(_TagError) then) =
      __$TagErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$TagErrorCopyWithImpl<$Res> extends _$TagFailureCopyWithImpl<$Res>
    implements _$TagErrorCopyWith<$Res> {
  __$TagErrorCopyWithImpl(_TagError _value, $Res Function(_TagError) _then)
      : super(_value, (v) => _then(v as _TagError));

  @override
  _TagError get _value => super._value as _TagError;
}

/// @nodoc

class _$_TagError extends _TagError {
  const _$_TagError() : super._();

  @override
  String toString() {
    return 'TagFailure.tagError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _TagError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notSupportedTag,
    required TResult Function() tagError,
  }) {
    return tagError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notSupportedTag,
    TResult Function()? tagError,
    required TResult orElse(),
  }) {
    if (tagError != null) {
      return tagError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotSupportedTag value) notSupportedTag,
    required TResult Function(_TagError value) tagError,
  }) {
    return tagError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotSupportedTag value)? notSupportedTag,
    TResult Function(_TagError value)? tagError,
    required TResult orElse(),
  }) {
    if (tagError != null) {
      return tagError(this);
    }
    return orElse();
  }
}

abstract class _TagError extends TagFailure {
  const factory _TagError() = _$_TagError;
  const _TagError._() : super._();
}
